[
  {
    "keys": [
      "|"
    ],
    "doc": "<h1>Core, <code>|</code> (\"bar\")</h1>\n<p>Core twigs are flow twigs.  The compiler essentially pins a Nock\nformula, or battery of formulas, to the subject.</p>\n<p>All <code>|</code> twigs are macros around <code>$core</code>. (See the <code>$core</code>\nsection in <a href=\"../../basic#-core-p-span-q-map-term-span\"><code>span</code></a> above.)\n<code>$core</code> uses the subject as the payload of a battery, whose arms are\ncompiled with the core itself as the subject.</p>\n<h2>Stems</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      "$"
    ],
    "doc": "<h1>Mold, <code>$</code> (\"buc\")</h1>\n<p>A <em>mold</em> is a <code>gate</code> (function) that helps us build simple and\nrigorous data structures.  (In fact, since \"mold\" sounds nasty,\nwe often call molds and mold builders \"structures.\")</p>\n<h2>Overview</h2>\n<p>A correct mold is a <em>normalizer</em>: an idempotent function across\nall nouns.  If the sample of a gate has span <code>%noun</code>, and its\nbody obeys the constraint that for any x, <code>=((mold x) (mold (mold\nx)))</code>, it's a normalizer and can be used as a mold.</p>\n<p>(Hoon is not dependently typed and so can't check idempotence\nstatically, so we can't actually tell if a mold matches this\ndefinition perfectly.  This is not actually a problem.)</p>\n<p>Twigs in the <code>$</code> family are macros designed for making molds.\nBut any Hoon twig may produce a mold.  (This is why <code>moss</code> is a\nsynonym for <code>twig</code>).</p>\n<p>Many macros <em>bunt</em> a mold, producing <code>:burn(:per(mold $))</code>.  This\nproduces a constant default value.  The formal range of a mold\n(the span of its bunt) is called its <em>icon</em>.</p>\n<p>Molds have two uses: defining simple and rigorous structures, and\nvalidating untrusted input data.  Validation, though very\nimportant, is a rare use case.  Except for direct raw input,\nit's generally a faux pas to rectify nouns at runtime -- or even\nin userspace.</p>\n<p>As a structure definition, a mold has three common uses.  One,\nwe bunt it for a default value (such as the sample in a gate).\nTwo, the product of some computation is cast to its icon, both\nchecking the type and regularizing it.  Three, it's used as a\nbuilding block in other molds.</p>\n<p>In any case, since molds are just functions, we can use\nfunctional programming to assemble interesting molds.  For\ninstance, <code>(map foo bar)</code> is a table from mold <code>foo</code> to mold\n<code>bar</code>.  <code>map</code> is not a mold; it's a function that makes a mold.\nMolds and mold builders are generally described together.</p>\n<h2>Stems</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      "%"
    ],
    "doc": "<h1>Call, <code>%</code> (\"cen\")</h1>\n<p>We've already covered <code>$wing</code> and <code>$limb</code>.  These are simple \nforms of the <em>invocation</em> family of twigs, <code>%</code>, whose general \nform is <code>$make</code>, <code>%=</code>.</p>\n<h2>Stems</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      ":"
    ],
    "doc": "<h1>Cells, <code>:</code> (\"col\")</h1>\n<p>The cell twigs, <code>$cons</code> and friends, are simple and regular.\nAll <code>:</code> twigs expand to <code>$cons</code>, which makes a pair (just like\nthe Lisp <code>cons</code> operator).</p>\n<h2>Stems</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      "."
    ],
    "doc": "<h1>Nock, <code>.</code> (dot)</h1>\n<p>Anything Nock can do, Hoon can do also.</p>\n<h2>Twigs</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      "^"
    ],
    "doc": "<h1>Cast, <code>^</code> (\"ket\")</h1>\n<p><code>$cast</code>, <code>$like</code>, and <code>$name</code> let us adjust spans without\nviolating type constraints.</p>\n<p>The <code>nest</code> algorithm which tests span subtyping is conservative;\nit never allows invalid nests, it sometimes rejects valid nests.</p>\n<h2>Twigs</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      ";"
    ],
    "doc": "<h1>Make, <code>;</code> (\"sem\")</h1>\n<p>Miscellaneous useful macros.</p>\n<h2>Twigs</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      "~"
    ],
    "doc": "<h1>Hints, <code>~</code> (\"sig\")</h1>\n<p>Twigs that use Nock <code>10</code> to pass non-semantic info to the\ninterpreter.</p>\n<h2>Twigs</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      "="
    ],
    "doc": "<h1>Flow, <code>=</code> (\"tis\")</h1>\n<p>Flow twigs change the subject.  (Or more precisely, a flow twig\ncompiles at least one of its subtwigs with a different subject.)\nAll non-flow twigs (except cores) pass the subject down unchanged.</p>\n<h2>Overview</h2>\n<p>The simplest way to change the subject is to compose two twigs, \n<code>p</code> and <code>q</code>.  Let <code>x</code> be <code>(mint subject p)</code>, with product span \n<code>p.x</code> and nock formula <code>q.x</code>.  Let <code>y</code> be <code>(mint p.x q)</code>.  Then\ntheir composition is <code>[p.y [7 q.x q.y]]</code>.</p>\n<p>This composition is the <code>$per</code> twig.  A close relative is <code>$pin</code>,\nwhich is <code>$per</code> over <code>[p .]</code>.  The new subject is a cell of <code>p</code>\nand the old subject.  <code>$pin</code> is the simplest Hoon equivalent of\n\"declaring a variable\" (introducing new data into the subject).</p>\n<p>Another way to change the subject is to mutate it.  With the\n<code>$set</code> twig, given a wing that resolves to a leg, we can write\ninstead of reading, <em>installing</em> a new value at that leg.  Of\ncourse, we are creating a copy, not modifying the original.</p>\n<p>There are many flow stems, all small variations on these three.</p>\n<h2>Twigs</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      "?"
    ],
    "doc": "<h1>Test, <code>?</code> (\"wut\")</h1>\n<p>Hoon has the usual branches and logical tests.  For pattern\nmatching, it also has a <code>$fits</code> twig that tests whether a value\nmatches the icon of a mold.  And it has branch inference,\nlearning from <code>$fits</code> tests in the condition of <code>:if</code> twigs.</p>\n<h2>Overview</h2>\n<p>All <code>?</code> runes expand to <code>$if</code> (<code>?:</code>) and/or <code>$fits</code> (<code>?=</code>).</p>\n<p>If the condition of an <code>$if</code> is a <code>$fits</code>, <em>and</em> the <code>$fits</code> is\ntesting a leg of the subject, the compile specializes the subject\nspan for the branches of the <code>$if</code>.  Branch inference also works\nfor twigs which expand to <code>$if</code>.</p>\n<p>The test does not have to be a single <code>$fits</code>; the compiler can\nanalyze arbitrary boolean logic (<code>$and</code>, <code>$or</code>, <code>$not</code>) with full \nshort-circuiting.  Equality tests (<code>=</code>) are <em>not</em> analyzed.</p>\n<p>If the compiler detects that the branch is degenerate (only one\nside is taken), it fails with an error.</p>\n<h2>Twigs</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      "!"
    ],
    "doc": "<h1>Wild, <code>!</code> (\"zap\")</h1>\n<h2>Twigs</h2>\n<p><list dataPreview=\"true\" className=\"runes\"></list></p>"
  },
  {
    "keys": [
      ":knit"
    ],
    "doc": "<h1><code>:knit</code></h1>\n<p><code>{$knit p/(list (each @t seed))}</code>: text string with interpolation.</p>\n<h3>Produces</h3>\n<p>A list-shaped string (<code>tape</code>) of the items in <code>p</code>, which are\neither constant <code>@t</code> multibyte UTF-8 strings (<code>cord</code>) or twigs\nproducing a <code>tape</code>.</p>\n<h3>Syntax</h3>\n<p>Irregular: <code>\"foobar\"</code>.</p>\n<p>Irregular: <code>\"foo{(weld \"moo\" \"baz\")}bar\"</code>.</p>\n<h3>Examples</h3>\n<p>String:</p>\n<p><code>~zod:dojo&gt; \"hello, world.\"\n\"hello, world.\"</code></p>\n<p>String with interpolation:</p>\n<p><code>~zod:dojo&gt; =+(planet=\"world\" \"hello, {planet}\")`.\n\"hello, %world.\"</code></p>\n<p>String with interpolated prettyprinting:</p>\n<p><code>~zod:dojo&gt; =+(planet=%world \"hello, {&lt;planet&gt;}\")`.\n\"hello, %world.\"</code></p>"
  },
  {
    "keys": [
      ":path"
    ],
    "doc": "<h1><code>:path</code></h1>\n<p><code>{$path p/(list (each @ta seed))}</code>: path with interpolation.</p>\n<h3>Produces</h3>\n<p>A null-terminated list if  of the items in <code>p</code>, which are either constant\n<code>@ta</code> atoms (<code>knot</code>), or twigs producing a <code>knot</code>.</p>\n<h3>Syntax</h3>\n<p>Irregular: <code>/foo/bar/baz</code>.</p>\n<p>Irregular: <code>\"foo{(weld \"moo\" \"baz\")}bar\"</code>.</p>\n<h3>Examples</h3>\n<p><code>~zod/dojo&gt; /foo/bar/baz\n/foo/bar/baz\n~zod/dojo&gt; /foo/[`@ta`(cat 3 %moo %bar)]/baz\n/foo/moobar/baz/\n~zod:dojo&gt; /\n~</code></p>"
  },
  {
    "keys": [
      ":rock"
    ],
    "doc": "<h1><code>:rock</code></h1>\n<p><code>{$rock p/term q/@}</code>; a constant, cold atom.</p>\n<h3>Produces</h3>\n<p>A cold (fixed) atom <code>q</code> with aura <code>a</code>.</p>\n<h3>Syntax</h3>\n<p>Irregular: any warm atom (<code>:sand</code>) form, prefixed with <code>%</code>.</p>\n<p>Irregular: <code>%foo</code>, <code>@tas</code>, symbol.  Character constraints: <code>a-z</code>\nlowercase to start, <code>a-z</code> or <code>0-9</code> thereafter, with infix \nhyphens (<code>hep</code>), \"kebab-case.\"</p>\n<p>Irregular: <code>~</code>, <code>@n</code>, null (<code>0</code>).</p>\n<h3>Examples</h3>\n<p><code>~zod:dojo&gt; ?? %foobar\n  [%atom %tas [~ u=125.762.588.864.358]]\n%foobar\n~zod:dojo&gt; ?? %'foobar'\n  [%atom %t [~ u=125.762.588.864.358]]\n%'foobar'\n~zod:dojo&gt; ?? 'foobar'\n  [%atom %t ~]\n'foobar'</code></p>"
  },
  {
    "keys": [
      ":sand"
    ],
    "doc": "<h1><code>:sand</code></h1>\n<p><code>{$sand p/term q/@}</code>; a constant, warm atom.</p>\n<h3>Produces</h3>\n<p>A warm (variable) atom <code>q</code> with aura <code>a</code>.</p>\n<h3>Syntax by example</h3>\n<p>Irregular.  A table of examples:</p>\n<p><code>@c    UTF-32                   ~-foobar\n@da   128-bit absolute date    ~2016.4.23..20.09.26..f27b..dead..beef..babe\n                               ~2016.4.23\n@dr   128-bit relative date    ~s17          (17 seconds)\n                               ~m20          (20 minutes)\n                               ~d42          (42 days)\n@f    loobean                  &amp;             (0, yes)\n                               |             (1, no)\n@p                             ~zod          (0)\n@rd   64-bit IEEE float        .~3.14        (pi)\n                               .~-3.14       (negative pi)\n@rs   32-bit IEEE float        .3.14         (pi)\n                               .-3.14        (negative pi)\n@rq   128-bit IEEE float       .~~~3.14      (pi)\n@rh   16-bit IEEE float        .~~3.14       (pi)\n@sb   signed binary            --0b10        (2)\n                               -0b101        (-5)\n@sd   signed decimal           --2           (2)\n                               -5            (-5)\n@sv   signed base32            --0v68        (200)\n                               -0vfk         (-500)\n@sw   signed base64            --0w38        (200)\n                               -0w7Q         (500)\n@sx   signed hexadecimal       --0x2         (2)\n                               -0x5          -5\n@t    UTF-8 text (cord)        'foobar'\n@ta   ASCII text (knot)        ~.foobar\n@ub   unsigned binary          0b10          (2)\n@uc   bitcoin address          0c1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa\n@ud   unsigned decimal         42            (42)\n                               1.420         (1420)\n@uv   unsigned base32          0v3ic5h.6urr6 \n@uw   unsigned base64          0wsC5.yrSZC\n@ux   unsigned hexadecimal     0xcafe.babe</code></p>\n<p>The <code>@uv</code> characters are <code>0-9</code>, <code>a-v</code>.  The <code>@uw</code> characters are \n<code>0-9</code>, <code>a-z</code>, <code>A-Z</code>, <code>-</code> and <code>~</code>.</p>"
  },
  {
    "keys": [
      ":door",
      "|_"
    ],
    "doc": "<h1><code>:door  |_  \"barcab\"</code></h1>\n<p><code>{$door p/moss q/(map term foot)}</code>: form a door, a many-armed core\nwith a sample.</p>\n<h2>Expands to</h2>\n<p><code>:new  p\n:core \n  q\n==</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>battery</em>.</p>\n<h2>Discussion</h2>\n<p>A door is the general case of a gate (function).  A gate is a\ndoor with only one arm, the empty name <code>$</code>.</p>\n<p>Other languages have no real equivalent of a door, but we often\nsee the pattern of multiple functions with the same argument\nlist, or with shared argument structure.  In Hoon, this shared\nstructure becomes a door.</p>\n<p>Calling a door is just like calling a gate, but the caller needs\nto specify the arm.  For instance, to call the gate <code>foo</code> as a\ndoor, instead of <code>(foo bar)</code> we would write <code>~($ foo bar)</code>.  This\nis an irregular form for <code>:open($ foo bar)</code>, <code>%~</code>, \"censig\".</p>\n<h2>Examples</h2>\n<p>A trivial door:</p>\n<p><code>/~zod:dojo&gt; =mol  |_  a/@ud\n                  ++  succ  +(a)\n                  ++  prev  (dec a)\n                  --\n/~zod:dojo&gt; ~(succ mol 1)\n2\n/~zod:dojo&gt; ~(succ mol ~(succ mol ~(prev mol 5)))\n6</code></p>\n<p>A more interesting door, from the kernel library:</p>\n<p><code>++  ne\n  |_  tig=@\n  ++  d  (add tig '0')\n  ++  x  ?:((gte tig 10) (add tig 87) d)\n  ++  v  ?:((gte tig 10) (add tig 87) d)\n  ++  w  ?:(=(tig 63) '~' ?:(=(tig 62) '-' ?:((gte tig 36) (add tig 29) x)))\n  --</code></p>\n<p>The <code>ne</code> door prints a digit in base 10, 16, 32 or 64:</p>\n<p><code>~zod:dojo&gt; `@t`~(x ne 12)\n'c'</code></p>"
  },
  {
    "keys": [
      ":core",
      "|%"
    ],
    "doc": "<h1><code>:core  |%  \"barcen\"</code></h1>\n<p>Form a core <code>{battery payload}</code> with subject as the payload.</p>\n<h2>Produces</h2>\n<p>A core with battery <code>p</code>.  Payload is the subject.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>battery</em>.</p>\n<h2>Discussion</h2>\n<p>A core is like an \"object\" in a conventional language, but its\nattributes (<em>arms</em>) are functions on the core, not the core and\nan argument.  A \"method\" on a core is an arm producing a gate.</p>\n<h2>Examples</h2>\n<p>A trivial core:</p>\n<p><code>~zod:dojo&gt; =foo  =+  x  58\n                 |%\n                 ++  n  (add 42 x)\n                 ++  g  |=  b/@\n                        (add b n)\n                 --\n~zod:dojo&gt; n.foo\n100\n~zod:dojo&gt; (g.foo 1)\n101</code></p>\n<p>In this trivial example, <code>g</code> id ther</p>"
  },
  {
    "keys": [
      ":trap.",
      "|."
    ],
    "doc": "<h1><code>:trap. |.  \"bardot\"</code></h1>\n<p><code>{$trap p/seed}</code>: form a trap, a core with one arm <code>$</code>.</p>\n<h2>Expands to</h2>\n<p><code>:core\n++  $  p\n--</code> </p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>A trap is a deferred computation.</p>\n<h2>Examples</h2>\n<p>A trivial trap:</p>\n<p><code>~zod:dojo&gt; =foo |.(42)\n~zod:dojo&gt; $:foo\n42\n~zod:dojo&gt; (foo)\n42</code></p>\n<p>A more interesting trap:</p>\n<p><code>~zod:dojo&gt; =foo  :var  reps  10\n                 :var  step  0\n                 :var  outp  0\n                 :trap\n                 :if  =(step reps)\n                   outp\n                 :moar(outp (add outp 2), step +(step))\n~zod:dojo&gt; (foo)\n20</code></p>\n<p>Note that we can use <code>:moar()</code> or <code>$()</code> to recurse back into the\ntrap, since it's a core with an <code>$</code> arm.</p>\n<blockquote>\n<p><code>:moar()</code> expands to <code>:make($)</code> (<code>%=($)</code>), accepting a <em>jogging</em> body\ncontaining a list of changes to the subject.</p>\n</blockquote>"
  },
  {
    "keys": [
      ":loop",
      "|-"
    ],
    "doc": "<h1><code>:loop  |-  \"barhep\"</code></h1>\n<p><code>{$loop p/seed}</code>: form a trap and kick it.</p>\n<h2>Expands to</h2>\n<p><code>:rap  $\n:core\n++  $  p\n--</code> </p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>The <code>:loop</code> keyword (and <code>|-</code> rune) can be thought of as a \"recursion point\" -\nsince <code>:loop</code> makes a <code>:trap</code> (a core with one arm named <code>$</code>), we can recurse\nback into it with <code>:moar()</code> or <code>$()</code>.</p>\n<blockquote>\n<p><code>:moar()</code> expands to <code>:make($)</code> (<code>%=($)</code>), accepting a <em>jogging</em> body\ncontaining a list of changes to the subject.</p>\n</blockquote>\n<h2>Examples</h2>\n<p>A trivial loop doesn't even recurse:</p>\n<p><code>~zod:dojo&gt; |-(42)\n42</code></p>\n<p>The classic loop is a decrement:</p>\n<p><code>~zod:dojo&gt; =foo  :var  a  42\n                 :var  b  0\n                 :loop\n                 :if  =(a +(b))\n                   b\n                 :moar(b +(b))\n~zod:dojo&gt; foo\n41</code></p>"
  },
  {
    "keys": [
      ":gill",
      "|*"
    ],
    "doc": "<h1><code>:gill  |*  \"bartar\"</code></h1>\n<p><code>{$gill p/moss q/seed}</code>: form a gill, a wet one-armed \ncore with sample.</p>\n<h2>Expands to</h2>\n<p><code>:new   p\n:core\n+-  $\n  q\n--</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>In a normal (dry) gate, your argument is converted into the\nsample type.  In a generic (wet) gate or gill, your argument type\npasses through the function, rather as if it was a macro (there\nis still only one copy of the code, however).</p>\n<p>Genericity is a powerful and dangerous tool.  Use gills only if\nyou think you know what you're doing. </p>\n<p>Just as with a <code>:gate</code>, we can recurse back into a <code>:gill</code> with <code>:moar()</code> or <code>$()</code>.</p>\n<blockquote>\n<p><code>:moar()</code> expands to <code>:make($)</code> (<code>%=($)</code>), accepting a <em>jogging</em> body\ncontaining a list of changes to the subject.</p>\n</blockquote>\n<h2>Examples</h2>\n<p>Wet and dry gates in a nutshell:</p>\n<p><code>~zod:dojo&gt; =foo :gate({a/* b/*} [b a])\n~zod:dojo&gt; =bar :gill({a/* b/*} [b a])\n~zod:dojo&gt; (foo %cat %dog)\n[6.778.724 7.627.107]\n~zod:dojo&gt; (bar %cat %dog)\n[%dog %cat]</code></p>\n<p>The dry gate does not preserve the span of <code>a</code> and <code>b</code>; the wet\ngate does.</p>"
  },
  {
    "keys": [
      ":gate",
      "|="
    ],
    "doc": "<h1><code>:gate  |=  \"bartis\"</code></h1>\n<p><code>{$gate p/moss q/seed}</code>: form a gate, a dry one-armed core with sample.</p>\n<h2>Expands to</h2>\n<p><code>:new   p\n:core\n++  $\n  q\n--</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>A gate is a core with one arm named <code>$</code>, so, just as with <code>:loop</code> (<code>|-</code>),\nwe can recurse back into it with <code>:moar()</code> or <code>$()</code>.</p>\n<blockquote>\n<p><code>:moar()</code> expands to <code>:make($)</code> (<code>%=($)</code>), accepting a <em>jogging</em> body\ncontaining a list of changes to the subject.</p>\n</blockquote>\n<h2>Examples</h2>\n<p>A trivial gate:</p>\n<p><code>~zod:dojo&gt; =foo |=(a/@ +(a))\n~zod:dojo&gt; (foo 20)\n21</code></p>\n<p>A slightly less trivial gate:</p>\n<p><code>~zod:dojo&gt; =foo  :gate  {a/@ b/@}\n                 (add a b)\n~zod:dojo&gt; (foo 20 400)\n420</code></p>"
  },
  {
    "keys": [
      ":base"
    ],
    "doc": "<h1><code>:base</code></h1>\n<p><code>{$base p/$@(?($noun $cell $bean $null) {$atom p/aura})}</code>: trivial molds.</p>\n<h2>Produces</h2>\n<p>A mold for the base in <code>p</code>.  <code>$noun</code> is any noun; <code>$atom</code> is any\natom; <code>$cell</code> is a cell of nouns; <code>$bean</code> is a loobean, <code>?(</code>@f<code>0</code>@f<code>1)</code>.  <code>$null</code> is zero with aura <code>@n</code>.</p>\n<h2>Syntax</h2>\n<p>Irregular: <code>*</code> makes <code>$noun</code>, <code>^</code> makes <code>$cell</code>, <code>?</code> makes\n<code>$bean</code>, <code>$~</code> makes <code>$null</code>, <code>@aura</code> makes atom <code>aura</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; (* %foo)\n7.303.014\n~zod:dojo&gt; ($~ 0)\n~\n~zod:dojo&gt; (^ 0)\n^\n~zod:dojo&gt; (@ux [1 1])\n0x0</code></p>"
  },
  {
    "keys": [
      ":shoe",
      "$_"
    ],
    "doc": "<h1><code>:shoe  $_  \"buccab\"</code></h1>\n<p><code>{$shoe p/seed}</code>: mold which normalizes to an example.</p>\n<h2>Expands to</h2>\n<p><code>:gate  *\np</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<p>Irregular: <code>_foo</code> is <code>:shoe(foo)</code>.</p>\n<h2>Discussion</h2>\n<p>A shoe discards the sample it's supposededly normalizing, and\nproduces its example instead.</p>\n<h2>Examples</h2>\n<p>```\n~zod:dojo&gt; =foo :shoe([%foobar %moobaz])</p>\n<p>~zod:dojo&gt; (foo %foo %bar)\n[%foobar %moobaz]</p>\n<p>~zod:dojo&gt; <code>foo</code>[%foobar %moobaz]\n[%foobar %moobaz]</p>\n<p>~zod:dojo $:foo\n[%foobar %moobaz]\n```</p>"
  },
  {
    "keys": [
      ":book",
      "$%"
    ],
    "doc": "<h1><code>:book  $%  \"buccen\"</code></h1>\n<p><code>{$book p/(list {{aura @} moss})}</code>: mold which recognizes a union tagged by head atom.</p>\n<h2>Normalizes to</h2>\n<p>For any item <code>i</code> in <code>p</code>, a cell whose head is the atom <code>q.p.i.p</code>,\nand whose tail recognizes <code>q.i.p</code>.</p>\n<p>Void if <code>p</code> is empty.</p>\n<h2>Defaults to</h2>\n<p>For the first item <code>i</code> in <code>p</code>, the cell <code>[q.p.i.p $:q.i.p]</code>.\nCrashes if <code>p</code> is empty.</p>\n<h2>Syntax</h2>\n<p>Regular form: <em>2-running</em>.</p>\n<h2>Discussion</h2>\n<p>A book is a tagged union, an extremely common data model.</p>\n<p>Each item in a book is called a \"page.\"  Make sure the first page\nin the book terminates, or the default will be an infinite loop!</p>\n<h2>Examples</h2>\n<p>```\n~zod:dojo&gt; =foo :book({$foo p/@ud q/@ud} {$bar p/@ud})</p>\n<p>~zod:dojo&gt; (foo [%bar 37])\n[%bar p=37]</p>\n<p>~zod:dojo&gt; $:foo\n[%foo p=0 q=0]~\n```</p>"
  },
  {
    "keys": [
      ":bank",
      "$:"
    ],
    "doc": "<h1><code>:bank  $:  \"buccol\"</code></h1>\n<p><code>{$bank p/(list moss)}</code>: form a mold which recognizes a tuple.</p>\n<h2>Normalizes</h2>\n<p>The tuple the length of <code>p</code>, normalizing each item, defaulting\nwhere the tuple does not match.</p>\n<p>Void if <code>p</code> is empty.</p>\n<h2>Defaults to</h2>\n<p>The tuple the length of <code>p</code>, defaulting each items.</p>\n<p>Crashes if <code>p</code> is empty.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<p>Irregular: <code>{a b c}</code> is <code>:bank(a b c)</code>.</p>\n<h2>Examples</h2>\n<p>```\n~zod:dojo&gt; =foo :bank(p/@ud q/@tas)</p>\n<p>~zod:dojo&gt; (foo 33 %foo)\n[p=33 q=%foo]</p>\n<p>~zod:dojo&gt; <code>foo</code>[33 %foo]\n[p=33 q=%foo]</p>\n<p>~zod:dojo&gt; $:foo\n[p=0 q=%$]\n```</p>"
  },
  {
    "keys": [
      ":lamb",
      "$-"
    ],
    "doc": "<h1><code>:lamb  $- \"buchep\"</code></h1>\n<p><code>{$lamb p/moss q/moss}</code>: mold which normalizes to an example gate.</p>\n<h2>Expands to</h2>\n<p><code>:shoe\n:iron\n:gate  p\n$:q</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>Since a lamb (ie, lambda), is a shoe, it is not useful for normalizing, just\nfor typechecking.  In particular, the existence of lambs does <em>not</em> let us send\ngates or other cores over the network!</p>\n<h2>Examples</h2>\n<p>```\n~zod:dojo&gt; =foo :lamb($foo $bar)</p>\n<p>~zod:dojo&gt; ($:foo %foo)\n%bar\n```</p>"
  },
  {
    "keys": [
      ":bush",
      "$^"
    ],
    "doc": "<h1><code>:bush  $^  \"bucket\"</code></h1>\n<p><code>{$bush p/moss q/moss}</code>: mold which normalizes a union tagged by head depth.</p>\n<h2>Normalizes to</h2>\n<p>Default, if the sample is an atom; <code>p</code>, if the head of the sample\nis an atom; <code>q</code> otherwise.</p>\n<h2>Defaults to</h2>\n<p>The default of <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p>```\n~zod:dojo&gt; =a :book({$foo p/@ud q/@ud} {$bar p/@ud})</p>\n<p>~zod:dojo&gt; =b :bush({a a} a)</p>\n<p>~zod:dojo&gt; (b [[%bar 33] [%foo 19 22]])\n[[%bar p=33] [%foo p=19 q=22]]</p>\n<p>~zod:dojo&gt; (b [%foo 19 22])\n[%foo p=19 q=22]</p>\n<p>~zod:dojo&gt; $:b \n[%bar p=0]\n```</p>"
  },
  {
    "keys": [
      ":claw",
      "$@"
    ],
    "doc": "<h1><code>:claw  $@  \"bucpat\"</code></h1>\n<p><code>{$claw p/moss q/moss}</code>: mold which normalizes a union tagged by depth.</p>\n<h2>Normalizes to</h2>\n<p>Default, if the sample is an atom; <code>p</code>, if the head of the sample\nis an atom; <code>q</code> otherwise.</p>\n<h2>Defaults to</h2>\n<p>The default of <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Product: a mold which applies <code>p</code> if its sample is an atom, \n<code>q</code> if its sample is a cell.</p>\n<p>Regular form: <em>2-fixed</em>.</p>\n<p>Example:\n```\n~zod:dojo&gt; =a :claw($foo :bank(p/$bar q/@ud))</p>\n<p>~zod:dojo&gt; (a %foo)\n%foo</p>\n<p>~zod:dojo&gt; <code>a</code>[%bar 99]\n[p=%bar q=99]</p>\n<p>~zod:dojo&gt; $:a\n[%foo p=0 q=0]\n```</p>"
  },
  {
    "keys": [
      ":coat",
      "$="
    ],
    "doc": "<h1><code>:coat  $=  \"buctis\"</code></h1>\n<p><code>{$coat p/@tas q/moss}</code>: mold which wraps a face around another mold.</p>\n<h2>Expands to</h2>\n<p><code>:gate  *\n:name(p :call(q +6))</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>foo/bar</code> is <code>:coat(foo bar)</code>.</p>\n<h2>Discussion</h2>\n<p>Note that the Hoon compiler is at least slightly clever about\ncompiling molds, and almost never has to actually put in a gate\nlayer (as seen in the expansion above) to apply a coat.</p>\n<h2>Examples</h2>\n<p>```\n~zod:dojo&gt; =a :coat(p $foo)</p>\n<p>~zod:dojo&gt; (a %bar)\np=%foo\n```</p>"
  },
  {
    "keys": [
      ":pick",
      "$?"
    ],
    "doc": "<h1><code>:pick  $?  \"bucwut\"</code></h1>\n<p><code>{$pick p/(list moss)}</code>: mold which normalizes a general union.</p>\n<h2>Normalizes to</h2>\n<p>The first item in <code>p</code> which normalizes the sample to itself;\notherwise, default.</p>\n<p>Void, if <code>p</code> is empty.</p>\n<h2>Defaults to</h2>\n<p>The first item in <code>p</code>. </p>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<p>Irregular: <code>?(%foo %bar)</code> is <code>$?(%foo %bar)</code>.</p>\n<h2>Discussion</h2>\n<p>For a union of atoms, a pick is fine.  For more complex nouns,\nalways try to use a book, claw or bush, at least if you expect\nyour mold to be used as a normalizer.</p>\n<h2>Examples</h2>\n<p>```\n~zod:dojo&gt; =a ?($foo $bar $baz)</p>\n<p>~zod:dojo&gt; (a %baz)\n%baz</p>\n<p>~zod:dojo&gt; (a [37 45])\n%foo</p>\n<p>~zod:dojo&gt; $:a\n$foo\n```</p>"
  },
  {
    "keys": [
      ":keep",
      "%_"
    ],
    "doc": "<h1><code>:keep  %_  \"cencab\"</code></h1>\n<p><code>{$keep p/wing q/(list (pair wing seed))}</code>: take a wing with changes,\npreserving type.</p>\n<h2>Expands to</h2>\n<p><code>:like(p :make(p q))</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>jogging</em>.</p>\n<h2>Discussion</h2>\n<p><code>:keep</code> is different from <code>:make</code> because <code>:make</code> can change the\nspan of a limb with mutations.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =foo [p=42 q=6]\n~zod:dojo&gt; foo(p %bar)\n[p=%bar q=6]\n~zod:dojo&gt; foo(p [55 99])\n[p=[55 99] q=6]\n~zod:dojo&gt; %_(foo p %bar)\n[p=7.496.034 99]\n~zod:dojo&gt; %_(foo p [55 99])\n! nest-fail</code></p>"
  },
  {
    "keys": [
      ":lace",
      "%."
    ],
    "doc": "<h1><code>:lace  %.  \"cendot\"</code></h1>\n<p><code>{$lace p/seed q/seed}</code>: call a gate (function), reversed.</p>\n<h2>Expands to</h2>\n<p><code>:call(q p)</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =add-triple |=({a/@ b/@ c/@} :(add a b c))\n~zod:dojo&gt; %.([1 2 3] add-triple)\n6</code></p>"
  },
  {
    "keys": [
      ":call",
      "%-"
    ],
    "doc": "<h1><code>:call  %-  \"cenhep\"</code></h1>\n<p><code>{$call p/seed q/seed}</code>: call a gate (function).</p>\n<h2>Expands to</h2>\n<p><code>:open($ p q)</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>(a)</code> is <code>$:a</code>; <code>(a b c d)</code> is <code>:call(a [b c d])</code>.</p>\n<h2>Discussion</h2>\n<p><code>$call</code> is a function call; <code>p</code> is the function (<code>gate</code>), <code>q</code> the\nargument.  <code>$call</code> is a special case of <code>$open</code>, and a gate is a\nspecial case of a door.</p>\n<p>In a gate, the modified core has only one anonymous arm; in a\ndoor it gets a full battery.  Intuitively, a gate defines one\nalgorithm it can compute upon its sample, <code>+6</code>. A door defines\nmany such algorithms.</p>\n<p>In classical languages, doors correspond to groups of functions \nwith the same argument list, or at least sharing a prefix.  In\nHoon, this shared sample is likely to be pulled into a door.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =add-triple |=({a/@ b/@ c/@} :(add a b c))\n~zod:dojo&gt; (add-triple 1 2 3)\n6\n~zod:dojo&gt; %-(add-triple [1 2 3])\n6</code></p>"
  },
  {
    "keys": [
      ":calq",
      "%^"
    ],
    "doc": "<h1><code>:calq  %^  \"cenket\"</code></h1>\n<p><code>{$calq p/seed q/seed r/seed s/seed}</code>: call with triple sample.</p>\n<h2>Expands to</h2>\n<p><code>:call(p [q r s])</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>4-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =add-triple |=({a/@ b/@ c/@} :(add a b c))\n~zod:dojo&gt; %^(add-triple 1 2 3)\n6</code></p>"
  },
  {
    "keys": [
      ":calt",
      "%+"
    ],
    "doc": "<h1><code>:calt  %+  \"cenlus\"</code></h1>\n<p><code>{$calt p/seed q/seed r/seed}</code>: call with pair sample.</p>\n<h2>Expands to</h2>\n<p><code>:call(p [q r])</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Examples</h2>\n<p>```\n~zod:dojo&gt; =add-triple |=({a/@ b/@ c/@} :(add a b c))\n~zod:dojo&gt; %+(add-triple 1 [2 3])\n6</p>"
  },
  {
    "keys": [
      ":open",
      "%~"
    ],
    "doc": "<h1><code>:open  %~  \"censig\"</code></h1>\n<p><code>{$cnsg p/wing q/seed r/seed}</code>: call with multi-armed door.</p>\n<h2>Expands to</h2>\n<p><code>:rap(p :make(q +6 r))</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<p>Irregular: <code>~(a b c)</code> is <code>%~(a b c)</code>; <code>~(a b c d e)</code> is <code>%~(a b\n[c d e])</code>.</p>\n<h2>Discussion</h2>\n<p><code>:open</code> is the general case of a function call, <code>:call</code>.  In\nboth, we replace the sample (<code>+6</code>) of a core.  In <code>:call</code> the\ncore is a gate and we </p>\n<p>Most languages do not have cores, doors, or <code>:open</code>.  \"Just\nlearn to step outside your linear, Western way of thinking.\"</p>\n<h2>Examples</h2>\n<p>See <a href=\"../../bar-core/cab-door\"><code>:door</code></a>.</p>"
  },
  {
    "keys": [
      ":make",
      "%="
    ],
    "doc": "<h1><code>:make  %=  \"centis\"</code></h1>\n<p><code>{$make p/wing q/(list (pair wing seed))}</code>: take a wing with changes.</p>\n<h2>Produces</h2>\n<p><code>p</code>, modified by the change list <code>q</code>.</p>\n<p>If <code>p</code> resolves to a leg, <code>q</code> is a list of changes to that leg.\nIf <code>p</code> resolves to an arm, <code>q</code> is a list of changes to the core\ncontaining that arm.  We compute the arm on the modified core.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>jogging</em>.</p>\n<p>Irregular: <code>foo(x 1, y 2, z 3)</code> is <code>:make(foo x 1, y 2, z 3)</code>.</p>\n<h2>Discussion</h2>\n<p>Note that <code>p</code> is a wing, not a twig.  Knowing that a function\ncall <code>(foo bar)</code> involves making <code>foo</code>, replacing its sample \nat slot <code>+6</code> with <code>bar</code>, and taking the <code>$</code> limb, you might think\n<code>(foo bar)</code> would mean <code>:make(foo +6 bar)</code>.</p>\n<p>But it's actually <code>:pin(foo :make($ +2 +6 bar))</code>.  Even if <code>foo</code>\nis a wing, we would just be mutating <code>+6</code> within the core that\ndefines the <code>foo</code> arm.  Instead we want to modify the <em>product</em>\nof <code>foo</code> -- the gate -- so we have to pin it into the subject.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =foo [p=5 q=6]\n~zod:dojo&gt; foo(p 42)\n[p=42 q=6]\n~zod:dojo&gt; foo(+3 99)\n[p=5 99]</code></p>"
  },
  {
    "keys": [
      ":scon",
      ":_"
    ],
    "doc": "<h1><code>:scon  :_  \"colcab\"</code></h1>\n<p><code>{$scon p/seed q/seed}</code>; construct a cell, inverted.</p>\n<h3>Expands to</h3>\n<p><code>:cons(q p)</code></p>\n<h3>Syntax</h3>\n<p>Regular: <em>2-fixed</em>.</p>\n<h3>Examples</h3>\n<p><code>~zod:dojo&gt; :_(1 2)\n[2 1]</code></p>"
  },
  {
    "keys": [
      ":cons",
      ":-"
    ],
    "doc": "<h1><code>:cons  :- \"colhep\"</code></h1>\n<p><code>{$cons p/seed q/seed}</code>: construct a cell (2-tuple).</p>\n<h2>Produces</h2>\n<p>The cell of <code>p</code> and <code>q</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>[a b]</code> is <code>:cons(a b)</code>.</p>\n<p>Irregular: <code>[a b c]</code> is <code>[a [b c]]</code>.</p>\n<p>Irregular: <code>a^b^c</code> is <code>[a b c]</code>.</p>\n<p>Irregular: <code>a+b</code> is <code>[%a b]</code>.</p>\n<p>Irregular: <code>`a</code> is <code>[~ a]</code>.</p>\n<p>Irregular: <code>~[a b]</code> is <code>[a b ~]</code>.</p>\n<p>Irregular: <code>[a b c]~</code> is <code>[[a b c] ~]</code>.</p>\n<h2>Discussion</h2>\n<p>Hoon twigs actually use the same \"autocons\" pattern as Nock \nformulas.  If you're assembling twigs (which usually only the\ncompiler does), <code>[a b]</code> is the same as <code>[%cons a b]</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; :-(1 2)\n[1 2]\n~zod:dojo&gt; 1^2\n[1 2]\n~zod:dojo&gt; 1+2\n[%1 2]\n~zod:dojo&gt; `1\n[~ 1]</code></p>"
  },
  {
    "keys": [
      ":conq",
      ":^"
    ],
    "doc": "<h1><code>:conq  :^  \"colket\"</code></h1>\n<p><code>{$conq p/seed q/seed r/seed s/seed}</code>: construct a quadruple (4-tuple).</p>\n<h2>Expands to</h2>\n<p><code>:cons(p :cons(q :cons(r s)))</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>4-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>/~zod:dojo&gt; :^(1 2 3 4)\n[1 2 3 4]\n/~zod:dojo&gt; :^  5  6\n              7\n            8\n[5 6 7 8]</code></p>"
  },
  {
    "keys": [
      ":cont",
      ":+"
    ],
    "doc": "<h1><code>:cont  :+  \"collus\"</code></h1>\n<p><code>{$cont p/seed q/seed r/seed}</code>: construct a triple (3-tuple).</p>\n<h2>Expands to:</h2>\n<p><code>:cons(p :cons(q r))</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>/~zod:dojo&gt; :+  1\n              2\n            3\n[1 2 3]\n/~zod:dojo&gt; :+(%a ~ 'b')\n[%a ~ 'b']</code></p>"
  },
  {
    "keys": [
      ":conl",
      ":~"
    ],
    "doc": "<h1><code>:conl  :~  \"colsig\"</code></h1>\n<p><code>{$conl p/(list seed)}</code>: construct a null-terminated list.</p>\n<h2>Expands to</h2>\n<p><code>|-(?~(p ~ :cons(i.p $(p t.p))))</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; :~(5 3 4 2 1)\n[5 3 4 2 1 ~]\n~zod:dojo&gt; ~[5 3 4 2 1]\n[5 3 4 2 1 ~]\n~zod:dojo&gt; :~  5\n               3\n               4\n               2\n               1\n           ==\n[5 3 4 2 1 ~]</code></p>"
  },
  {
    "keys": [
      ":conp",
      ":*"
    ],
    "doc": "<h1><code>:conp  :*  \"coltar\"</code></h1>\n<p><code>{$conp p/(list twig)}</code>: construct an n-tuple.</p>\n<h2>Expands to</h2>\n<p><code>|-(?~(p !! ?~(t.p i.p :cons(i.p $(p t.p)))))</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<h2>Examples</h2>\n<p><code>/~zod:dojo&gt; :*(5 3 4 1 4 9 0 ~ 'a')\n[5 3 4 1 4 9 0 ~ 'a']\n/~zod:dojo&gt; [5 3 4 1 4 9 0 ~ 'a']\n[5 3 4 1 4 9 0 ~ 'a']\n/~zod:dojo&gt; :*  5\n                3\n                4 \n                1\n                4\n                9\n                0\n                ~\n                'a'\n            ==\n[5 3 4 1 4 9 0 ~ 'a']</code></p>"
  },
  {
    "keys": [
      ":wish",
      ".^"
    ],
    "doc": "<h1><code>:wish  .^  \"dotket\"</code></h1>\n<p><code>{$wish p/moss q/seed}</code>: load from the Arvo namespace with Nock <code>11</code>.</p>\n<h2>Produces</h2>\n<p>The noun whose name is <code>q</code>, cast to the icon of <code>p</code>.</p>\n<h2>Discussion</h2>\n<p>Nock has no <code>11</code> instruction, of course.  But the virtual Nock\nused to run userspace code does.  Nock <code>11</code> loads from a\ntyped immutable namespace defined by its virtual context.</p>\n<p>We don't remold dynamically nouns in a <code>:wish</code>, but we do check\nthat the type of the value nests in <code>p</code>.</p>\n<h2>Examples</h2>"
  },
  {
    "keys": [
      ":bump",
      ".+"
    ],
    "doc": "<h1><code>:bump  .+  \"dotlus\"</code></h1>\n<p><code>{$bump p/seed}</code>: increment an atom with Nock <code>4</code>.</p>\n<h2>Produces</h2>\n<p><code>p</code> plus <code>1</code> if <code>p</code> is an atom; otherwise, crashes.  The product\natom has no aura.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<p>Irregular: <code>+(6)</code> is <code>.+(6)</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; +(6)\n7\n~zod:dojo&gt; +(%foo)\n7.303.015\n~zod:dojo&gt; +([1 2])\n! nest-fail</code></p>"
  },
  {
    "keys": [
      ":nock",
      ".*"
    ],
    "doc": "<h1><code>:nock  .*  \"dottar\"</code></h1>\n<p><code>{$nock p/seed q/seed}</code>: evaluate with Nock <code>2</code>.</p>\n<h2>Produces</h2>\n<p>Nock of formula <code>q</code> and subject <code>p</code>, with span <code>%noun</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>Note that <code>:nock</code> can be used to bypass the type system,\nthough its product contains no type information.  It's\nperfectly practical to use Hoon as a typeless language.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; .*([20 30] [0 2])\n20\n~zod:dojo&gt; .*(33 [4 0 1])\n34\n~zod:dojo&gt; .*(|.(50) [9 2 0 1])\n50\n~zod:dojo&gt; .*(12 [7 [`1 [4 `1]] [`2 `3 `2]])\n[12 13 12]\n~zod:dojo&gt; .*(~ [5 1^4 [4 1^3]])\n0\n~zod:dojo&gt; .*(~ [5 1^5 [4 1^3]])\n1</code></p>"
  },
  {
    "keys": [
      ":same",
      ".="
    ],
    "doc": "<h1><code>:same  .=  \"dottis\"</code></h1>\n<p><code>{$same p/seed q/seed}</code>: test for equality with Nock <code>5</code>.</p>\n<h2>Produces</h2>\n<p><code>&amp;</code>, <code>%.y</code>, <code>0</code> if <code>p</code> equals <code>q</code>; otherwise <code>|</code>, <code>%.n</code>, <code>1</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>=(a b)</code> is <code>.=(a b)</code>.</p>\n<h2>Discussion</h2>\n<p>Like Nock equality, <code>:same</code> tests if two nouns are the same,\nignoring invisible pointer structure.  Because in a conventional\nnoun implementation each noun has a lazy short hash, comparisons \nare fast unless the hash needs to be computed, or we are comparing\nseparate copies of identical nouns.  (Comparing large duplicates \nis a common cause of performance bugs.)</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =(0 0)\n%.y\n~zod:dojo&gt; =(1 2)\n%.n</code></p>"
  },
  {
    "keys": [
      ":deep",
      ".?"
    ],
    "doc": "<h1><code>:deep  .?  \"dotwut\"</code></h1>\n<p><code>{$deep p/seed}</code>: test for cell or atom with Nock <code>3</code>.</p>\n<h2>Produces</h2>\n<p><code>&amp;</code>, <code>%.y</code>, <code>0</code> if <code>p</code> is a cell; otherwise <code>|</code>, <code>%.n</code>, <code>1</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; .?(~)\n%.n\n~zod:dojo&gt; .?([2 3])\n%.y</code></p>"
  },
  {
    "keys": [
      ":iron",
      "^|"
    ],
    "doc": "<h1><code>:iron  ^|  \"ketbar\"</code></h1>\n<p><code>{$iron p/seed}</code>: convert a gold core to an iron core (contravariant).</p>\n<h2>Produces</h2>\n<p><code>p</code> as an iron core; crash if not a gold core.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>An iron core is an opaque function (gate or door).</p>\n<p>Theorem: if span <code>x</code> nests within span <code>a</code>, and span <code>y</code> nests\nwithin span <code>b</code>, a core accepting <code>b</code> and producing <code>x</code> nests\nwithin a iron core accepting <code>y</code> and producing <code>a</code>.</p>\n<p>Informally, a function fits an interface if the function has a\nmore specific result and/or a less specific argument than the\ninterface.</p>\n<h2>Examples</h2>\n<p>The prettyprinter shows the core metal (<code>.</code> gold, <code>|</code> iron):</p>\n<p><code>~zod:dojo&gt; |=(@ 1)\n&lt;1.gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151&gt;]&gt;\n~zod:dojo&gt; ^|(|=(@ 1))\n&lt;1|gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151&gt;]&gt;</code></p>"
  },
  {
    "keys": [
      ":cast",
      "^-"
    ],
    "doc": "<h1><code>:cast  ^-  \"kethep\"</code></h1>\n<p><code>{$cast p/moss q/seed}</code>: typecast by mold.</p>\n<h2>Expands to</h2>\n<p><code>:like(:bunt(p) q)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>`foo`bar</code> is <code>:cast(foo bar)</code>.</p>\n<h2>Discussion</h2>\n<p>It's a good practice to put a <code>:cast</code> at the top of every arm\n(including gates, loops, etc).  This cast is strictly necessary\nonly in the presence of head recursion (otherwise you'll get a\n<code>rest-loop</code> error, or if you really screw up spectacularly an \ninfinite loop in the compiler).</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; (add 90 7)\n97\n~zod:dojo&gt; `@t`(add 90 7)\n'a'\n~zod:dojo&gt; ^-(@t (add 90 7))\n'a'\n/~zod:dojo&gt; =foo  |=  a/@tas\n                  ^-  (unit @ta)\n                  `a\n/~zod:dojo&gt; (foo 97)\n[~ ~.a]</code></p>"
  },
  {
    "keys": [
      ":like",
      "^+"
    ],
    "doc": "<h1><code>:like  ^+  \"ketlus\"</code></h1>\n<p><code>{$like p/seed q/seed}</code>: typecast by example (seed).</p>\n<h2>Produces</h2>\n<p>The value of <code>p</code> with the span of <code>q</code>, if the span of <code>p</code> nests\nwithin the span of <code>q</code>.  Otherwise, <code>nest-fail</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; :like('text' %a)\n'a'</code></p>"
  },
  {
    "keys": [
      ":burn",
      "^~"
    ],
    "doc": "<h1><code>:burn  ^~  \"ketsig\"</code></h1>\n<p><code>{$burn p/seed}</code>: fold constant at compile time.</p>\n<h2>Produces</h2>\n<p><code>p</code>, folded as a constant if possible.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; (make '|-(42)')\n[%8 p=[%1 p=[1 42]] q=[%9 p=2 q=[%0 p=1]]]\n~zod:dojo&gt; (make '^~(|-(42))')\n[%1 p=42]</code></p>"
  },
  {
    "keys": [
      ":name",
      "^="
    ],
    "doc": "<h1><code>:name  ^=  \"kettis\"</code></h1>\n<p><code>{$name p/toga q/seed}</code>: name a value.</p>\n<h2>Produces</h2>\n<p>If <code>p</code> is a term, the product <code>q</code> with span <code>[%face p q]</code>.  <code>p</code>\nmay also be a tuple of terms, or a term-toga pair; the span of \n<code>q</code> must divide evenly into cells to match it.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>foo=bar</code> is <code>:name(foo bar)</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; a=1\na=1\n~zod:dojo&gt; ^=  a\n           1\na=1\n~zod:dojo&gt; [b c d]=[1 2 3 4]\n[b=1 c=2 d=[3 4]]\n~zod:dojo&gt; [b c d=[x y]]=[1 2 3 4]\n[b=1 c=2 d=[x=3 y4]]</code></p>"
  },
  {
    "keys": [
      ":lead",
      "^?"
    ],
    "doc": "<h1><code>:lead  ^?  \"ketwut\"</code></h1>\n<p><code>{$lead p/seed}</code>: convert any core to a lead core (bivariant).</p>\n<h2>Produces</h2>\n<p><code>p</code> as a lead core; crash if not a core.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>A lead core is an opaque generator; the payload can't be read or \nwritten.</p>\n<p>Theorem: if span <code>x</code> nests within span <code>a</code>, a lead core producing\n<code>x</code> nests within a lead core producing <code>a</code>.</p>\n<p>Informally, a more specific generator can be used as a less\nspecific generator.</p>\n<h2>Examples</h2>\n<p>The prettyprinter shows the core metal (<code>.</code> gold, <code>?</code> lead):</p>\n<p><code>~zod:dojo&gt; |=(@ 1)\n&lt;1.gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151&gt;]&gt;\n~zod:dojo&gt; ^?(|=(@ 1))\n&lt;1?gcq [@  @n &lt;250.yur 41.wda 374.hzt 100.kzl 1.ypj %151&gt;]&gt;</code></p>"
  },
  {
    "keys": [
      ":limb"
    ],
    "doc": "<h1><code>:limb</code></h1>\n<p><code>{$limb p/(each @ud {p/@ud q/@tas})}</code>: attribute of subject.</p>\n<h3>Produces</h3>\n<p>If <code>p</code> matches <code>{$&amp; p/@ud}</code>, slot <code>p.p</code> of the subject.</p>\n<p>If <code>p</code> matches <code>{$| p/@ud q/@tas}</code>, the <code>p</code>th match for <code>q</code>,\nusing the search traverse below.</p>\n<h3>Syntax</h3>\n<p>Irregular: <code>+15</code> is slot <code>15</code>, <code>[%&amp; 15]</code>.</p>\n<p>Irregular: <code>.</code> is slot <code>1</code>, the whole subject.</p>\n<p>Irregular: <code>foobar</code> is <code>[%| 0 %foobar]</code>.</p>\n<p>Irregular: <code>^^^foobar</code> is <code>[%| 3 %foobar]</code>.</p>\n<h3>Traverse</h3>\n<p>The search traverse takes a name <code>q</code> and a <em>skip count</em> <code>p</code>.</p>\n<p>The search product may be an <em>arm</em> or a <em>leg</em>.  A <em>leg</em> is a\nsubtree of the subject.  An arm defines a Nock formula and a\nsubject leg to compute the result.  Logically, a limb is an\nattribute -- computation or subtree, \"synthesized\" or \"natural\"\n-- of the subject.</p>\n<p>We search the subject span headfirst, depth-first, and pre-order.\nIf we descend to a <code>$face</code> span whose label matches the limb\nsymbol, the descent address is a leg.   The span is the span\nbeneath the label.  But if the <code>$face</code> label differs, the search\nskips this whole subtree.</p>\n<p>If we descend into a <code>$core</code> span in which the limb symbol is an\narm, we produce that arm.  If the limb symbol is not bound, we\ndescend into the payload (data) of the core.</p>\n<p>If the skip count <code>p</code> is nonzero, we pretend our first <code>p</code>\nmatches are actually mismatches.  This lets the programmer \"look\nthrough\" an overriding label.  No label anywhere is inaccessible.</p>\n<h3>Examples</h3>\n<p>The <code>:dojo</code> prompt gives you a subject with a decent namespace.\nTry</p>\n<p><code>~zod:dojo&gt; now\n~2016.4.25..01.39.59..a0f0</code></p>\n<p>You can also add variables to the subject, then use them.  (Note\nthat <code>=variable value</code> is not Hoon (language) syntax; it's <code>:dojo</code>\n(shell) syntax.)</p>\n<p><code>~zod:dojo&gt; =foo %bar\n~zod:dojo&gt; foo\n%bar</code></p>"
  },
  {
    "keys": [
      ":wing"
    ],
    "doc": "<h1><code>:wing</code></h1>\n<p><code>{$wing p/(list limb)</code>; a limb search path.</p>\n<h3>Produces</h3>\n<p>If <code>p</code> is null, the subject at leg <code>1</code>.  Otherwise, let <code>x</code> be\nthe <code>$wing</code> of <code>t.p</code>.  <code>x</code> is either an arm or a leg.  We compute\nlimb <code>i.p</code> on some subject leg <code>s</code>, where:</p>\n<p>If <code>x</code> is a leg/slot number, <code>s</code> is <code>x</code>.</p>\n<p>If <code>x</code> is an arm/subject-formula pair <code>[s f]</code>, <code>s</code> is <code>s.x</code>.</p>\n<h3>Syntax</h3>\n<p>Irregular: <code>a.b</code> finds limb <code>a</code> within limb <code>b</code> of the subject.</p>\n<h3>Discussion</h3>\n<p>It may be slightly hard to follow the formal definition above.</p>\n<p>Intuitively, Hoon wings are written in the opposite order\nfrom attribute dot-paths in most languages.  Hoon <code>a.b.c</code> is Java\n<code>c.b.a</code>; it means \"a within b within c.\"</p>\n<p>Any item in the wing can resolve to a leg (fragment) or arm\n(computation).  But if a non-terminal item in the wing would\nresolve to an arm, it resolves instead to the subject of the arm\n-- in other words, the core exporting that name.</p>\n<p>The mysterious idiom <code>..foo</code> produces the leg <code>foo</code> if <code>foo</code>\nis a leg; the core exporting <code>foo</code> if <code>foo</code> is an arm.  Since <code>.</code>\nis the same limb as <code>+</code>, <code>..foo</code> is the same wing as <code>+1.foo</code>.</p>\n<h3>Examples</h3>\n<p><code>~zod:dojo&gt; =a [foo=3 bar=[baz=1 moo=2]]\n~zod:dojo&gt; bar.a\n[baz=1 moo=2]\n~zod:dojo&gt; moo.bar.a\n2</code></p>"
  },
  {
    "keys": [
      ":wad",
      ";:"
    ],
    "doc": "<h1><code>:wad  ;:  \"semcol\"</code></h1>\n<p><code>{$wad p/seed q/(list seed)}</code>: call a binary function as an n-ary function.</p>\n<h2>Expands to</h2>\n<p><code>|-(?~(q !! ?~(t.q !! ?~(t.t.q :call(p i.q i.t.q) :call(p i.q $(q t.q))))))</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>running</em>.</p>\n<p>Irregular: <code>:(add a b c)</code> is <code>;:(add a b c)</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; (add 3 (add 4 5))\n12\n~zod:dojo&gt; ;:(add 3 4 5)\n12\n~zod:dojo&gt; :(add 3 4 5)\n12</code></p>"
  },
  {
    "keys": [
      ":nub",
      ";/"
    ],
    "doc": "<h1><code>:nub  ;/  \"semfas\"</code></h1>\n<p><code>{$nub p/seed}</code>: tape as XML element.</p>\n<h2>Expands to</h2>\n<p><code>[%$ [%$ p ~] ~]</code></p>\n<h2>Examples</h2>\n<p><code>~zod/try=&gt; :/(\"foo\"\n[[%$ [%$ \"foo] ~] ~]</code></p>"
  },
  {
    "keys": [
      ":fry",
      ";;"
    ],
    "doc": "<h1><code>:fry  ;;  \"semsem\"</code></h1>\n<p><code>{$fry p/moss q/seed}</code>: normalize with a mold, asserting fixpoint.</p>\n<h2>Expands to</h2>\n<p><code>:pin(:name(a (p q)) :sure(=(a (p a)) a))</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p>Fails because of auras:</p>\n<p><code>~zod:dojo&gt; ^-(tape ~[97 98 99])\n! nest-fail\n! exit</code></p>\n<p>Succeeds because molds don't care about auras:</p>\n<p><code>~zod:dojo&gt; ;;(tape ~[97 98 99])\n\"abc\"</code></p>\n<p>Succeeds because the mold normalizes:</p>\n<p><code>~zod:dojo&gt; (tape [50 51 52])\n\"23\"</code></p>\n<p>Fails because not a fixpoint:</p>\n<p><code>~zod:dojo&gt; ;;(tape [50 51 52])\n! exit</code></p>"
  },
  {
    "keys": [
      ":dip",
      ";~"
    ],
    "doc": "<h1><code>:dip  ;~  \"semsig\"</code></h1>\n<p><code>{$dip p/seed q/(list seed)}</code>: glue a pipeline together with a \nproduct-sample adapter.</p>\n<h2>Produces</h2>\n<p>The gates in <code>q</code> connected together using the gate <code>p</code>, which \ntransforms a <code>q</code> product and a <code>q</code> gate into a <code>q</code> sample.</p>\n<h2>Discussion</h2>\n<p>Apparently <code>:dip</code> is a \"Kleisli arrow.\"  Whatevs.  It's also \na close cousin of the infamous \"monad.\"  Don't let that bother\nyou either.  Hoon doesn't know anything about category theory,\nso you don't need to either.</p>\n<p><code>:dip</code> is often used in parsers, but is not only for parsers.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>running</em>.</p>\n<h2>Examples</h2>\n<p>A simple \"parser.\"  <code>trip</code> converts a <code>cord</code> (atomic string) to\na <code>tape</code> (linked string).</p>\n<p><code>~zod:dojo&gt; =cmp |=({a/tape b/$-(char tape)] `tape`?~(a ~ (weld (b i.a) t.a)))\n~zod:dojo&gt; ;~(cmp trip)\n&lt;1.xef [a=@ &lt;374.hzt 100.kzl 1.ypj %164&gt;]&gt;\n~zod:dojo&gt; (;~(cmp trip) 'a')\n\"a\"</code></p>\n<p>With just one gate in the pipeline <code>q</code>, the glue <code>p</code> is unused:</p>\n<p><code>~zod:dojo&gt; (;~(cmp trip |=(a/@ ~[a a])) 'a')\n\"aa\"\n~zod:dojo&gt; (;~(cmp trip |=(a/@ ~[a a])) '')\n\"\"</code></p>\n<p>But for multiple gates, we need it to connect the pipeline:</p>\n<p><code>~zod:dojo&gt; (;~(cmp trip ;~(cmp |=(a/@ ~[a a]) |=(a/@ &lt;(dec a)&gt;))) 'b')\n\"97b\"\n~zod:dojo&gt; (;~(cmp trip |=(a/@ ~[a a]) |=(a/@ &lt;(dec a)&gt;)) 'b')\n\"97b\"\n~zod:dojo&gt; (;~(cmp trip |=(a/@ ~[a a]) |=(a/@ &lt;(dec a)&gt;)) '')\n\"\"\n~zod:dojo&gt; (;~(cmp trip |=(a/@ ~[a a]) |=(a/@ &lt;(dec a)&gt;)) 'a')\n\"96a\"\n~zod:dojo&gt; (;~(cmp trip |=(a/@ ~[a a]) |=(a/@ &lt;(dec a)&gt;)) 'acd')\n\"96acd\"</code></p>"
  },
  {
    "keys": [
      ":show",
      "~|"
    ],
    "doc": "<h1><code>:show  ~|  \"sigbar\"</code></h1>\n<p><code>{$show p/seed q/seed}</code>: tracing printf.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>Prettyprints <code>p</code> in stack trace if <code>q</code> crashes.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ~|('sample error message' !!)\n'sample error message'\nford: build failed</code></p>"
  },
  {
    "keys": [
      ":poll",
      "~$"
    ],
    "doc": "<h1><code>:poll  ~$  \"sigbuc\"</code></h1>\n<p><code>{$poll p/term q/seed}</code>: profiling hit counter.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>If profiling is on, adds 1 to the hit counter for <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ~$(%foo 3)\n3</code></p>"
  },
  {
    "keys": [
      ":lurk",
      "~_"
    ],
    "doc": "<h1><code>:lurk  ~_  \"sigcab\"</code></h1>\n<p><code>{$lurk p/seed q/seed}</code>: user-formatted tracing printf.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>Shows <code>p</code> in stacktrace if <code>q</code> crashes.</p>\n<h2>Discussion</h2>\n<p><code>p</code> must produce a <code>tank</code> (prettyprint source).</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ~_([%leaf \"sample error message\"] !!)\n\"sample error message\"\nford: build failed</code></p>"
  },
  {
    "keys": [
      ":fast",
      "~%"
    ],
    "doc": "<h1><code>:fast  ~%  \"sigcen\"</code></h1>\n<p><code>{$fast p/term q/wing r/(list {term seed}) s/seed}</code>: jet registration.</p>\n<h2>Expands to</h2>\n<p><code>s</code>.</p>\n<h2>Convention</h2>\n<p>Register a core with name <code>p</code>, with parent at leg <code>q</code>, exporting\nthe named formulas <code>r</code>, constructed by <code>s</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>4-fixed</em>.  For <code>r</code>, use <code>~</code> if empty.  Otherwise, <em>jogging</em> \nbetween opening and closing <code>==</code>.</p>\n<h2>Discussion</h2>\n<p><code>:fast</code> is for registering cores.  A registered core declares its\nformal identity to the interpreter, which may or may not be able\nto recognize and/or accelerate it.</p>\n<p>Registered cores are organized in a containment hierarchy.\nThe parent core is at any leg within the child core.  When we\nregister a core, we state the leg to its parent, in the form of\nwing <code>q</code>.  We assume the parent is already registered -- as it\nmust be, if (a) we registered it on creation, (b) the child was\ncreated by an arm defined on the parent.</p>\n<p>(Cores are actually managed by their formula/battery.  Any\nfunction call will create a new core with a new sample, but\nbatteries are constant.  But it is not sufficient to match the\nbattery -- matching the semantics constrains the payload as well,\nsince the semantics of a battery may depend on any parent core\nand/or payload constant.)</p>\n<p>The purpose of registration is always performance-related.  It\nmay involve (a) a special-purpose optimizer or \"jet\", written\nfor a specific core and checked with a Merkle hash; (b) a\ngeneral-purpose hotspot optimizer or \"JIT\"; or (c) merely a\nhotspot declaration for profiling.</p>\n<p>As always with hints, the programmer has no idea which of (a),\n(b), and (c) will be applied.  She should use <code>:fast</code>\nindiscriminately on all hotspots, bottlenecks, etc, real or\nsuspected.</p>\n<p>The list <code>r</code> is a way for the Hoon programmer to help jet\nimplementors with named Nock formulas that act on the core.\nIn complex systems, jet implementations are often partial and\nwant to call back into userspace.</p>\n<p>The child core contains the parent, of course.  When we register\na core, we state the leg to its parent, in the form of wing <code>q</code>.\nWe assume that the parent -- any core within the payload -- is\nalready registered.</p>\n<p>must already be registered.\nThe interpreter can thus </p>\n<p><code>p</code> is the name of this core within its parent; <code>q</code> is a the leg </p>\n<p>Registers a jet in core <code>s</code> so that it can be called when that code is run.</p>\n<p>Regularm form: <em>4-fixed</em></p>\n<h2>Examples</h2>\n<p>Here's the AES </p>\n<pre><code>++  aesc                                                ::  AES-256\n  ~%  %aesc  +  ~\n  |%\n  ++  en                                                ::  ECB enc\n    ~/  %en\n    |=  {a/@I b/@H}  ^-  @uxH\n    =+  ahem\n    (be &amp; (ex a) b)\n  ++  de                                                ::  ECB dec\n    ~/  %de\n    |=  {a/@I b/@H}  ^-  @uxH\n    =+  ahem\n    (be | (ix (ex a)) b)\n  --\n</code></pre>\n<p>Here we label the entire <code>++aesc</code> core for optimization. You can see the\njet in <code>jets/e/aesc.c</code>.</p>"
  },
  {
    "keys": [
      ":funk",
      "~/"
    ],
    "doc": "<h1><code>:funk  ~/  \"sigfas\"</code></h1>\n<p><code>{$funk p/term q/seed}</code>: jet registration for gate with\nregistered context.</p>\n<h2>Expands to</h2>\n<p><code>:fast(p +7 ~ q)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p>From the kernel: \n<code>++  add\n  ~/  %add\n  |=  {a/@ b/@}\n  ^-  @\n  ?:  =(0 a)  b\n  $(a (dec a), b +(b))</code></p>"
  },
  {
    "keys": [
      ":thin",
      "~<"
    ],
    "doc": "<h1><code>:thin  ~&lt;  \"siggal\"</code></h1>\n<p><code>{$thin p/$@(term {p/term q/seed}) q/seed}</code>: raw hint, applied to \nproduct.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.  For the dynamic form, write <code>%term.twig</code>.</p>\n<h2>Discussion</h2>\n<p><code>:thin</code> is only used for jet hints (<code>:funk</code> and <code>:fast</code>) at the \nmoment; we are not telling the interpreter something about the\ncomputation we're about to perform, but rather about its product.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; (make '~&lt;(%a 42)')\n[%7 p=[%1 p=42] q=[%10 p=97 q=[%0 p=1]]]\n~zod:dojo&gt; (make '~&lt;(%a.+(.) 42)')\n[%7 p=[%1 p=42] q=[%10 p=[p=97 q=[%4 p=[%0 p=1]]] q=[%0 p=1]]]</code></p>"
  },
  {
    "keys": [
      ":hint",
      "~>"
    ],
    "doc": "<h1><code>:hint  ~&gt;  \"siggar\"</code></h1>\n<p><code>{$hint p/$@(term {p/term q/seed}) q/seed}</code>: raw hint, applied\nto computation.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.  For the dynamic form, write <code>%term.twig</code>.</p>\n<h2>Discussion</h2>\n<p>Hoon has no way of telling what hints are used and what aren't.\nHints are all conventions at the interpreter level.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ~&gt;(%a 42)\n42</code></p>\n<p>Running the compiler:</p>\n<p><code>~zod:dojo&gt; (make '~&gt;(%a 42)')\n[%10 p=97 q=[%1 p=42]]\n~zod:dojo&gt; (make '~&gt;(%a.+(2) 42)')\n[%10 p=[p=97 q=[%4 p=[%1 p=2]]] q=[%1 p=42]]</code></p>"
  },
  {
    "keys": [
      ":memo",
      "~+"
    ],
    "doc": "<h1><code>:memo  ~+  \"siglus\"</code></h1>\n<p><code>{$memo p/seed}</code>: cache a computation.</p>\n<h2>Expands to</h2>\n<p><code>p</code>.</p>\n<h2>Convention</h2>\n<p>Caches the formula and subject of <code>p</code> in a local cache (generally \ntransient in the current event).</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Examples</h2>\n<p>This may pause for a second:</p>\n<p><code>~zod:dojo&gt; %.(25 |=(a/@ ?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a))))))\n121.393</code></p>\n<p>This may make you want to press ^C:</p>\n<p><code>~zod:dojo&gt; %.(30 |=(a/@ ?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a))))))\n1.346.269</code></p>\n<p>This should work fine:</p>\n<p><code>~zod:dojo&gt; %.(100 |=(a/@ ~+(?:((lth a 2) 1 (add $(a (sub a 2)) $(a (dec a)))))))\n573.147.844.013.817.084.101</code></p>"
  },
  {
    "keys": [
      ":dump",
      "~&"
    ],
    "doc": "<h1><code>:dump  ~&amp;  \"sigpam\"</code></h1>\n<p><code>{$dump p/seed q/seed}</code>: debugging printf.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>Prettyprints <code>p</code> on the console before computing <code>q</code>. </p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ~&amp;('halp' ~)\n'halp'\n~</code></p>"
  },
  {
    "keys": [
      ":ddup",
      "~="
    ],
    "doc": "<h1><code>:ddup  ~=  \"sigtis\"</code></h1>\n<p><code>{$ddup p/seed q/seed}</code>: detect duplicate.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>If <code>p</code> equals <code>q</code>, produce <code>p</code> instead of <code>q</code>.</p>\n<h2>Discussion</h2>\n<p>Duplicates are especially bad news in Hoon, because comparing them\ntakes O(n) time.  Use <code>~=</code> to kill them as they breed.</p>\n<h2>Examples</h2>\n<p>This code traverses a tree and replaces all instances of <code>42</code> with\n<code>420</code>:</p>\n<p><code>~zod:dojo&gt; =foo  |=  a/(tree) \n                 ?~(a ~ ~=(a [?:(=(n.a 42) 420 n.a) $(a l.a) $(a r.a)]))\n~zod:dojo&gt; (foo 42 ~ ~)\n[420 ~ ~]</code></p>\n<p>Without <code>~=</code>, it would build a copy of a completely unchanged tree.  Sad!</p>"
  },
  {
    "keys": [
      ":warn",
      "~?"
    ],
    "doc": "<h1><code>:warn  ~?  \"sigwut\"</code></h1>\n<p><code>{$warn p/seed q/seed r/seed}</code>: conditional debug printf.</p>\n<h2>Expands to</h2>\n<p><code>r</code>.</p>\n<h2>Convention</h2>\n<p>If <code>p</code> is true, prettyprints <code>q</code> on the console before computing <code>r</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>4-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ~?((gth 1 2) 'oops' ~)\n~\n~zod:dojo&gt; ~?((gth 1 0) 'oops' ~)\n'oops'\n~</code></p>"
  },
  {
    "keys": [
      ":peep",
      "~!"
    ],
    "doc": "<h1><code>:peep  ~!  \"sigzap\"</code></h1>\n<p><code>{$peep p/seed q/seed}</code>: print type on compilation fail.</p>\n<h2>Expands to</h2>\n<p><code>q</code>.</p>\n<h2>Convention</h2>\n<p>If compilation of <code>q</code> fails, prints the span of <code>p</code> in the trace.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; a\n! -find.a\n~zod:dojo&gt; ~!('foo' a)\n! @t\n! find.a</code></p>"
  },
  {
    "keys": [
      ":new",
      "=|"
    ],
    "doc": "<h1><code>:new  =|  \"tisbar\"</code></h1>\n<p><code>{$new p/moss q/seed}</code>: combine a defaulted mold with the subject.</p>\n<h2>Expands to</h2>\n<p><code>:pin(:bunt(p) q)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p><code>:new</code> \"declares a variable\" which is \"uninitialized,\" presumably \nbecause you'll set it in a loop or similar.</p>\n<p>A common mistake is to forget that since <code>p</code> is moldy,\n<code>:new(foo=@ bar)</code> is wrong; you mean <code>:new(foo/@ bar)</code>, since\n<code>foo=@</code> is <code>:name(foo @)</code> (putting a face on a seed) and <code>foo/@</code>\nis <code>:coat(foo @)</code> (wrapping a face around a mold).</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =foo  |=  a/@\n                 =|  b/@\n                 =-  :(add a b c)\n                 c=2 \n~zod:dojo&gt; (foo 5)\n7</code></p>"
  },
  {
    "keys": [
      ":fix",
      "=:"
    ],
    "doc": "<h1><code>:fix  =:  \"tiscol\"</code></h1>\n<p><code>{$fix p/(list (pair wing seed)) q/seed}</code>: change multiple legs in the subject.</p>\n<h2>Expands to</h2>\n<p><code>:per(:keep(. p q) r)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>jogging</em>, then <em>1-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =+  a=[b=1 c=2]\n           =:  c.a  4\n               b.a  3\n             ==\n           a\n[b=3 c=4]</code></p>"
  },
  {
    "keys": [
      ":set",
      "=."
    ],
    "doc": "<h1><code>:set  =.  \"tisdot\"</code></h1>\n<p><code>{$set p/wing q/seed r/seed}</code>: change one leg in the subject.</p>\n<h2>Expands to</h2>\n<p><code>:per(:keep(. p q) r)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>As usual, we are not actually mutating the subject, just creating\na new subject with a changed value.  Note that the mutation uses\n<code>:keep</code> (<code>%_</code>), so the type doesn't change.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =+  a=[b=1 c=2]\n           =.  b.a  3\n           a\n[b=3 c=2]\n~zod:dojo&gt; =+  a=[b=1 c=2]\n           =.(b.a 3 a)\n[b=3 c=2]</code></p>"
  },
  {
    "keys": [
      ":var",
      "=/"
    ],
    "doc": "<h1><code>:var  =/  \"tisfas\"</code></h1>\n<p><code>{$var p/taco q/seed r/seed}</code>: combine a named and/or typed \nnoun with the subject.</p>\n<h2>Expands to</h2>\n<p><code>?@(p :pin(:name(p q) r) :pin(:cast(:coat(p q) r)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p><code>p</code> can be either a symbol or a symbol/mold.  If it's just a\nsymbol, <code>:var</code> \"declares a type-inferred variable.\"  It has a\nmold, <code>:var</code> \"declares a type-checked variable.\"</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =foo  |=  a/@\n                 =/  b  1\n                 =/  c/@  2\n                 :(add a b c)\n~zod:dojo&gt; (foo 5)\n8</code></p>"
  },
  {
    "keys": [
      ":rap",
      "=<"
    ],
    "doc": "<h1><code>:rap  =&lt;  \"tisgal\"</code></h1>\n<p><code>{$rap p/seed q/seed}</code>: compose two twigs, inverted.</p>\n<h2>Expands to</h2>\n<p><code>:per(q p)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<p>Irregular: <code>foo:bar</code> is <code>:rap(foo bar)</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; b:[a=1 b=2 c=3]\n2\n~zod:dojo&gt; [. .]:(add 2 4)\n[6 6]</code></p>"
  },
  {
    "keys": [
      ":per",
      "=>"
    ],
    "doc": "<h1><code>:per  =&gt;  \"tisgar\"</code></h1>\n<p><code>{$per p/seed q/seed}</code>: compose two twigs.</p>\n<h2>Produces</h2>\n<p><code>q</code>, compiled against the product of <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =&gt;([a=1 b=2 c=3] b)\n2\n~zod:dojo&gt; =&gt;((add 2 4) [. .])\n[6 6]</code></p>"
  },
  {
    "keys": [
      ":nip",
      "=-"
    ],
    "doc": "<h1><code>:nip  =-  \"tishep\"</code></h1>\n<p><code>{$pin p/seed q/seed}</code>: combine a new noun with the subject, inverted.</p>\n<h2>Expands to</h2>\n<p><code>:per(:cons(q .) p)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p><code>:nip</code> looks better than <code>:pin</code> when the twig you're pinning \nis much smaller than the twig that uses it.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =foo  |=  a/@\n                 =+  :name(b 1)\n                 =-  :(add a b c)\n                 c=2 \n~zod:dojo&gt; (foo 5)\n8</code></p>"
  },
  {
    "keys": [
      ":sip",
      "=^"
    ],
    "doc": "<h1><code>:sip  =^  \"tisket\"</code></h1>\n<p><code>{$sip p/taco q/wing r/seed s/seed}</code>: pin the head of a pair; change \na leg with the tail.</p>\n<h2>Expands to</h2>\n<p><code>:var(p -.r :set(q +.r s))</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>4-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>We use <code>:sip</code> when we have a state machine with a function that\nproduces a cell, whose head is a result and whose tail is a new\nstate.  We want to use the head as a new variable, and stuff the\ntail back into wherever we stored the old state.</p>\n<p>This may also remind you of Haskell's State monad.</p>\n<h2>Examples</h2>\n<p>The <code>og</code> core is a stateful pseudo-random number generator.\nWe have to change the core state every time we generate a\nrandom number, so we need to <code>:sip</code>:</p>\n<p><code>~zod:dojo&gt; =+  rng=~(. og 420)\n           =^  r1  rng  (rads:rng 100)\n           =^  r2  rng  (rads:rng 100)\n           [r1 r2]\n[99 46]</code></p>"
  },
  {
    "keys": [
      ":pin",
      "=+"
    ],
    "doc": "<h1><code>:pin  =+  \"tislus\"</code></h1>\n<p><code>{$pin p/seed q/seed}</code>: combine a new noun with the subject.</p>\n<h2>Expands to</h2>\n<p><code>:per(:cons(p .) q)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p><code>:pin</code> is the simplest way of \"declaring a variable.\"</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =foo  |=  a/@\n                 =+  :name(b 1)\n                 =+  c=2\n                 :(add a b c)\n~zod:dojo&gt; (foo 5)\n8</code></p>"
  },
  {
    "keys": [
      ":rev",
      "=;"
    ],
    "doc": "<h1><code>:rev  =;  \"tissem\"</code></h1>\n<p><code>{$rev p/taco q/seed r/seed}</code>: combine a named and/or typed noun with the\nsubject, inverted.</p>\n<h2>Expands to</h2>\n<p><code>?@(p :pin(:name(p r) q) :pin(:cast(:coat(p r) q)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =foo  :gate  a/@\n                 :var   b  1\n                 :rev   c/@  :(add a b c)\n                 2\n~zod:dojo&gt; (foo 5)\n8</code></p>"
  },
  {
    "keys": [
      ":aka",
      "=*"
    ],
    "doc": "<h1><code>:aka  =* \"tistar\"</code></h1>\n<p><code>{$aka p/term q/seed r/seed}</code>: define an alias.</p>\n<h2>Produces</h2>\n<p><code>r</code>, compiled with a subject in which <code>p</code> is aliased to <code>q</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>The difference between aliasing and pinning is that the subject\nnoun stays the same; the alias is just recorded in its span.\n<code>q</code> is calculated every time you use the <code>p</code> alias, of course.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; \n    =+  a=1\n    =*  b  a\n    [a b]\n[1 1]\n~zod:dojo&gt; \n    =+  a=1\n    =*  b  a\n    =.  a  2\n    [a b]\n[2 2]</code></p>"
  },
  {
    "keys": [
      ":or",
      "?|"
    ],
    "doc": "<h1><code>:or  ?|  \"wutbar\"</code></h1>\n<p><code>{$or p/(list seed)}</code>: logical or.</p>\n<h2>Expands to</h2>\n<p><code>:ifno  p  \n  |\n:if  i.p\n  &amp;\n:moar(p t.p)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<p>Irregular: <code>|(foo bar baz)</code> is <code>?|(foo bar baz)</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; |(=(6 42) =(42 42))\n%.y</code></p>"
  },
  {
    "keys": [
      ":if",
      "?:"
    ],
    "doc": "<h1><code>:if  ?:  \"wutcol\"</code></h1>\n<p><code>{$if p/seed q/seed r/seed}</code>: branch on a boolean test.</p>\n<h2>Produces</h2>\n<p>If <code>p</code> produces yes, then <code>q</code>. If <code>p</code> produces no, <code>r</code>.\nIf <code>p</code> is not a boolean, compiler yells at you.</p>\n<p>The subjects of <code>q</code> and <code>r</code> are constrained to match any\npattern-matching algebra in <code>p</code>.  The analysis, which is\nconservative, understands any combination of <code>:fits</code>\n(<code>?=</code>), <code>:and</code> (<code>?&amp;</code>), <code>:or</code> (<code>?|</code>), and <code>:not</code> (<code>?!</code>),\nand reduces the subject appropriately when compiling.</p>\n<p>If test analysis reveals that either branch is not taken,\nor if <code>p</code> is not a boolean, compilation fails.  However,\nan untaken branch can be indicated with the <code>:lost</code> twig.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>Short-circuiting in boolean tests works as you'd expect\nand includes the expected inference.  For instance,\nif you write <code>:and(a b)</code>, <code>b</code> is only executed if <code>a</code> is\npositive, and compiled with that assumption.</p>\n<p>Note also that all other branching twigs reduce to <code>:if</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ?:((gth 1 2) 3 4)\n4</code></p>"
  },
  {
    "keys": [
      ":lest",
      "?."
    ],
    "doc": "<h1><code>:lest  ?.  \"wutdot\"</code></h1>\n<p><code>{$lest p/seed q/seed r/seed}</code>: branch on a boolean test, inverted.</p>\n<h2>Expands to</h2>\n<p><code>:if  p\n  r\nq</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>As usual with inverted forms, use <code>:lest</code> when the positive\ntwig of an <code>:if</code> is much heavier than the negative twig.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ?.((gth 1 2) 3 4)\n3\n~zod:dojo&gt; ?.(?=(%a 'a') %not-a %yup)\n%yup\n~zod:dojo&gt; ?.  %.y\n             'this false case is less heavy than the true case'\n           ?:  =(2 3)\n             'two not equal to 3'\n           'but see how \\'r is much heavier than \\'q?'\n'but see how \\'r is much heavier than \\'q?'</code></p>"
  },
  {
    "keys": [
      ":deny",
      "?<"
    ],
    "doc": "<h1><code>:deny  ?&lt;  \"wutgal\"</code></h1>\n<p><code>{$deny p/seed q/seed}</code>: negative assertion.</p>\n<h2>Expands to</h2>\n<p><code>:if  p\n  :zpzp\nq</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ?&lt;(=(3 4) %foo)\n%foo</code></p>"
  },
  {
    "keys": [
      ":sure",
      "?>"
    ],
    "doc": "<h1><code>:sure  ?&gt;  \"wutgar\"</code></h1>\n<p><code>{$sure p/seed q/seed}</code>: positive assertion.</p>\n<h2>Expands to</h2>\n<p><code>:lest  p\n  :zpzp\nq</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ?&gt;(=(3 3) %foo)\n%foo</code></p>"
  },
  {
    "keys": [
      ":case",
      "?-"
    ],
    "doc": "<h1><code>:case  ?-  \"wuthep\"</code></h1>\n<p><code>{$case p/wing q/(list (pair moss seed))}</code>: switch against a \nunion, with no default.</p>\n<h2>Expands to</h2>\n<p><code>:ifno  q\n  :lost \n:if  :fits(p.i.q p)\n  q.i.q\n:moar(q t.q)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>, then <em>jogging</em>.</p>\n<h2>Discussion</h2>\n<p>The compiler makes sure that your code neither misses a case of\nthe union, nor includes a double case that isn't there.  This is\nnot special handling for <code>:case</code>, just a consequence of the\nsemantics of <code>:if</code>, which <code>:case</code> reduces to.</p>\n<p>A missing case will throw the <code>mint-lost</code> error.  An extra case\nwill throw <code>mint-vain</code>.  (Ecclesiastes did nothing wrong.)</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =cor  |=  vat/?($a $b)\n                 ?-  vat\n                   $a  20\n                   $b  42\n                 ==\n~zod:dojo&gt; (cor %a)\n20\n~zod:dojo&gt; (cor %b)\n42\n~zod:dojo&gt; (cor %c)\n! nest-fail</code></p>"
  },
  {
    "keys": [
      ":ifcl",
      "?^"
    ],
    "doc": "<h1><code>:ifcl  ?^  \"wutket\"</code></h1>\n<p><code>{$ifcl p/wing q/seed r/seed}</code>: branch on whether a wing \nof the subject is null.</p>\n<h2>Expands to</h2>\n<p><code>:if  :fits(^ p)\n  q\nr</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>Regular form: <em>3-fixed</em></p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ?^(0 1 2)\n! mint-vain\n! exit\n~zod:dojo&gt; ?^(`*`0 1 2)\n2\n~zod:dojo&gt; ?^(`*`[1 2] 3 4)\n3</code></p>"
  },
  {
    "keys": [
      ":deft",
      "?+"
    ],
    "doc": "<h1><code>:deft  ?+  \"wutlus\"</code></h1>\n<p><code>{$case p/wing q/seed r/(list (pair moss seed))}</code>: switch against \na union, with a default.</p>\n<h2>Expands to</h2>\n<p><code>:ifno  r\n  q\n:if  :fits(p.i.r p)\n  q.i.r\n:moar(r t.r)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>, then <em>jogging</em>.</p>\n<h2>Discussion</h2>\n<p>An extra case will throw <code>mint-vain</code>.  A lost case defaults.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =cor  |=  vat/?($a $b)\n                 ?+  vat  240\n                   $a  20\n                   $b  42\n                 ==\n~zod:dojo&gt; (cor %a)\n20\n~zod:dojo&gt; (cor %b)\n42\n~zod:dojo&gt; (cor %c)\n240</code></p>"
  },
  {
    "keys": [
      ":and",
      "?&"
    ],
    "doc": "<h1><code>:and  ?&amp;  \"wutpam\"</code></h1>\n<p><code>{$and p/(list seed)}</code>: logical and.</p>\n<h2>Expands to</h2>\n<p><code>:ifno  p  \n  &amp;\n:lest  i.p\n  |\n:moar(p t.p)</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>running</em>.</p>\n<p>Irregular: <code>&amp;(foo bar baz)</code> is <code>?&amp;(foo bar baz)</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; &amp;(=(6 6) =(42 42))\n%.y</code></p>"
  },
  {
    "keys": [
      ":ifat",
      "?@"
    ],
    "doc": "<h1><code>:ifat  ?@  \"wutpat\"</code></h1>\n<p><code>{$ifat p/wing q/seed r/seed}</code>: branch on whether a wing \nof the subject is an atom.</p>\n<h2>Expands to</h2>\n<p><code>:if  :fits($~ p)\n  q\nr</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ?@(0 1 2)\n! mint-vain\n! exit\n~zod:dojo&gt; ?@(`*`0 1 2)\n1\n~zod:dojo&gt; ?@(`*`[1 2] 3 4)\n4</code></p>"
  },
  {
    "keys": [
      ":ifno",
      "?~"
    ],
    "doc": "<h1><code>:ifno  ?~  \"wutsig\"</code></h1>\n<p><code>{$ifno p/wing q/seed r/seed}</code>: branch on whether a wing \nof the subject is null.</p>\n<h2>Expands to</h2>\n<p><code>:if  :fits($~ p)\n  q\nr</code></p>\n<h2>Syntax</h2>\n<p>Regular: <em>3-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>It's bad style to use <code>:ifno</code> to test for any zero atom.  Use it\nonly for a true null, <code>~</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =foo \"\"\n~zod:dojo&gt; ?~(foo 1 2)\n11</code></p>"
  },
  {
    "keys": [
      ":fits",
      "?="
    ],
    "doc": "<h1><code>:fits  ?=  \"wuttis\"</code></h1>\n<p><code>{$fits p/moss q/wing}</code>: test pattern match.</p>\n<h2>Produces</h2>\n<p><code>&amp;</code> (yes) if the noun at <code>q</code> is in the icon of <code>p</code>;\n<code>|</code> (no) otherwise.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Discussion</h2>\n<p><code>:fits</code> is not as powerful as it might seem.  For instance, it\ncan't generate a loop -- you cannot (and should not) use it to \ntest whether a <code>*</code> is a <code>(list @)</code>.  Nor can it validate atomic \nauras.</p>\n<p>Patterns should be as weak as possible.  Unpack one layer of\nunion at a time.  Don't confirm things the type system knows.</p>\n<p>For example, when matching a book containing a page <code>{$foo p/@\nq/{@ @}}</code>, the proper pattern is <code>{$foo *}</code>.  You have one\nquestion, which is whether the head of the noun is <code>%foo</code>.</p>\n<p>A common error is <code>find.$</code>, meainng <code>p</code> is not a mold.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; =bar [%foo %bar %baz]\n~zod:dojo&gt; ?=({$foo *} bar)\n%.y</code></p>"
  },
  {
    "keys": [
      ":not",
      "?!"
    ],
    "doc": "<h1><code>:not  ?!  \"wutzap\"</code></h1>\n<p><code>{$not p/seed}</code>: logical not.</p>\n<h2>Expands to</h2>\n<p><code>:same(%.n p)</code></p>\n<p>Produces the logical \"not\" of <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<p>Irregular: <code>!foo</code> is <code>?!(foo)</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; ?!(.=(1 2))\n%.y\n~zod:dojo&gt; !&amp;\n%.n\n~zod:dojo&gt; !|\n%.y\n~zod:dojo&gt; !(gth 5 6)\n%.y</code></p>"
  },
  {
    "keys": [
      ":wrap",
      "!>"
    ],
    "doc": "<h1><code>:wrap  !&gt;  \"zapgar\"</code></h1>\n<p><code>{$wrap p/seed}</code>: wrap a noun in its span.</p>\n<h2>Produces</h2>\n<p>A cell whose tail is <code>p</code>, and whose head is the static span of p.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Discussion</h2>\n<p>In Hoon, dynamic type is static type compiled at runtime.  This\nspan-noun cell is generally called a <code>vase</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; !&gt;(1)\n[p=#t/@ud q=1]</code></p>"
  },
  {
    "keys": [
      ":code",
      "!="
    ],
    "doc": "<h1><code>:code  !=  \"zaptis\"</code></h1>\n<p><code>{$code p/seed}</code>: make the Nock formula for a twig.</p>\n<h2>Produces</h2>\n<p>The Nock generated by <code>p</code>.</p>\n<h2>Syntax</h2>\n<p>Regular: <em>1-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; !=(20)\n[1 20]\n~zod:dojo&gt; !=(~zod)\n[1 0]\n~zod:dojo&gt; !=((add 2 2))\n[8 [9 3.110.356 0 31] 9 2 [0 4] [7 [0 3] 1 2 2] 0 11]</code></p>"
  },
  {
    "keys": [
      ":need",
      "!?"
    ],
    "doc": "<h1><code>:need  !?  \"zapwut\"</code></h1>\n<p><code>{$need p/@ q/seed}</code>: restrict Hoon version.</p>\n<h2>Produces</h2>\n<p><code>q</code>, if <code>p</code> is greater than or equal to the Hoon kelvin version.\n(Versions count down; the current version is 150.)</p>\n<h2>Syntax</h2>\n<p>Regular: <em>2-fixed</em>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; !?(264 (add 2 2))\n4\n~zod:dojo&gt; !?(164 (add 2 2))\n4\n~zod:dojo&gt; !?(64 (add 2 2))\n! exit</code></p>"
  },
  {
    "keys": [
      ":fail",
      "!!"
    ],
    "doc": "<h1><code>:fail  !!  \"zapzap\"</code></h1>\n<p><code>{$fail $~}</code>: crash.</p>\n<h2>Produces</h2>\n<p>Nothing.  Always crashes, with span <code>%void</code>.</p>\n<h2>Syntax</h2>\n<p><code>!!</code></p>\n<h2>Discussion</h2>\n<p><code>%void</code> nests in every other span, so you can stub out anything with <code>!!</code>.</p>\n<h2>Examples</h2>\n<p><code>~zod:dojo&gt; !!\n! exit</code></p>"
  }
]
